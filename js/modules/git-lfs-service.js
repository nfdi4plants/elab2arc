/**
 * Git LFS Service for elab2arc
 * Custom implementation - no external LFS library dependencies
 * Uses native browser crypto.subtle for SHA-256
 *
 * @module GitLFSService
 * @version 1.0.0
 */

const LFS_SIZE_THRESHOLD = 10 * 1024 * 1024; // 10MB
const LFS_CONFIG_PATH = '.gitattributes';

/**
 * Initialize LFS in repository
 * Creates .gitattributes with LFS patterns
 *
 * @param {object} fs - Filesystem object (memfs)
 * @param {string} gitRoot - Root directory of git repository
 * @returns {Promise<void>}
 */
async function initLFS(fs, gitRoot) {
  const gitattributesPath = `${gitRoot}/${LFS_CONFIG_PATH}`;

  let content = '';
  try {
    content = await fs.promises.readFile(gitattributesPath, 'utf8');
  } catch (e) {
    // File doesn't exist, create new
  }

  // Add LFS patterns if not present
  const marker = '# Auto-generated by elab2arc LFS service';
  if (content.includes(marker)) {
    console.log('[LFS] Already initialized, skipping');
    return; // Already initialized
  }

  const lfsPatterns = [
    marker,
    '# Large files handled by Git LFS',
    '*.zip filter=lfs diff=lfs merge=lfs -text',
    '*.tar.gz filter=lfs diff=lfs merge=lfs -text',
    '*.tar filter=lfs diff=lfs merge=lfs -text',
    '*.rar filter=lfs diff=lfs merge=lfs -text',
    '*.7z filter=lfs diff=lfs merge=lfs -text',
    '*.psd filter=lfs diff=lfs merge=lfs -text',
    '*.tif filter=lfs diff=lfs merge=lfs -text',
    '*.tiff filter=lfs diff=lfs merge=lfs -text',
    '*.gz filter=lfs diff=lfs merge=lfs -text',
    ''
  ];

  const newContent = content ? content + '\n\n' + lfsPatterns.join('\n') : lfsPatterns.join('\n');
  await fs.promises.writeFile(gitattributesPath, newContent);
  console.log('[LFS] Initialized .gitattributes');
}

/**
 * Check if file should use LFS based on size
 *
 * @param {number} fileSize - Size of file in bytes
 * @returns {boolean} True if file should use LFS
 */
function shouldUseLFS(fileSize) {
  return fileSize > LFS_SIZE_THRESHOLD;
}

/**
 * Create LFS pointer file content
 *
 * @param {string} oid - SHA-256 OID of the file
 * @param {number} size - Size of the file in bytes
 * @returns {string} LFS pointer file content
 */
function createLFSPointer(oid, size) {
  return `version https://git-lfs.github.com/spec/v1
oid sha256:${oid}
size ${size}
`;
}

/**
 * Calculate SHA-256 of file content using browser native API
 *
 * @param {ArrayBuffer} buffer - File content buffer
 * @returns {Promise<string>} Hex-encoded SHA-256 hash
 */
async function calculateSHA256(buffer) {
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Upload file to LFS storage via batch API
 * Returns LFS pointer info { oid, size }
 *
 * @param {string} url - Git repository URL
 * @param {string} auth - Authorization header value
 * @param {Uint8Array} fileContent - File content to upload
 * @param {string} corsProxy - CORS proxy URL
 * @returns {Promise<{oid: string, size: number}>} LFS pointer info
 */
async function uploadToLFS(url, auth, fileContent, corsProxy) {
  const oid = await calculateSHA256(fileContent);
  const size = fileContent.byteLength;

  // Construct LFS batch API endpoint
  const repoUrl = new URL(url);
  const baseUrl = repoUrl.pathname.replace(/\.git$/, '');
  const lfsEndpoint = `${repoUrl.origin}${baseUrl}.git/info/lfs/objects/batch`;

  // LFS batch request body
  const batchRequest = {
    operation: 'upload',
    transfers: ['basic'],
    objects: [{ oid, size }]
  };

  // Use CORS proxy for LFS API calls
  const proxyUrl = corsProxy + encodeURIComponent(lfsEndpoint);

  console.log(`[LFS] Requesting upload for ${oid} (${(size/1024/1024).toFixed(2)}MB)`);

  const response = await fetch(proxyUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/vnd.git-lfs+json',
      'Accept': 'application/vnd.git-lfs+json',
      ...(auth && { 'Authorization': auth })
    },
    body: JSON.stringify(batchRequest)
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`LFS batch API failed (${response.status}): ${errorText}`);
  }

  const result = await response.json();

  // Check for errors in response
  if (result.objects && result.objects[0] && result.objects[0].error) {
    const lfsError = result.objects[0].error;
    throw new Error(`LFS error: ${lfsError.message} (code: ${lfsError.code})`);
  }

  // Upload the actual file to the provided URL
  const uploadAction = result.objects[0].actions.upload;
  console.log(`[LFS] Uploading to: ${uploadAction.href}`);

  const uploadResponse = await fetch(uploadAction.href, {
    method: 'PUT',
    headers: uploadAction.headers || {},
    body: fileContent
  });

  if (!uploadResponse.ok) {
    throw new Error(`LFS upload failed: ${uploadResponse.statusText}`);
  }

  console.log(`[LFS] Upload complete for ${oid}`);
  return { oid, size };
}

/**
 * Process file for git add with LFS support
 * If file is large, uploads to LFS and creates pointer file
 *
 * @param {object} fs - Filesystem object (memfs)
 * @param {object} git - isomorphic-git instance
 * @param {string} gitRoot - Root directory of git repository
 * @param {string} filepath - Relative path to file
 * @param {string} url - Git repository URL
 * @param {string} auth - Authorization header value
 * @param {string} corsProxy - CORS proxy URL
 * @returns {Promise<{usedLFS: boolean, size: number}>}
 */
async function addFileWithLFS(fs, git, gitRoot, filepath, url, auth, corsProxy) {
  const fullPath = `${gitRoot}/${filepath}`;

  try {
    // Read file content
    const content = await fs.promises.readFile(fullPath);
    const fileSize = content.byteLength;

    if (shouldUseLFS(fileSize)) {
      console.log(`[LFS] File ${filepath} (${formatBytes(fileSize)}) exceeds threshold, using LFS`);

      // Upload to LFS
      const lfsInfo = await uploadToLFS(url, auth, content, corsProxy);

      // Replace with pointer file
      const pointerContent = createLFSPointer(lfsInfo.oid, lfsInfo.size);
      const pointerBuffer = new TextEncoder().encode(pointerContent);
      await fs.promises.writeFile(fullPath, pointerBuffer);

      console.log(`[LFS] Created pointer for ${filepath} (sha256:${lfsInfo.oid})`);

      // Add to git (pointer file)
      await git.add({ fs, dir: gitRoot, filepath });

      return { usedLFS: true, size: fileSize };
    }

    // File is small, add normally
    await git.add({ fs, dir: gitRoot, filepath });

    return { usedLFS: false, size: fileSize };

  } catch (error) {
    console.error(`[LFS] Error processing file ${filepath}:`, error);
    throw error;
  }
}

/**
 * Format bytes to human readable size
 *
 * @param {number} bytes - Size in bytes
 * @returns {string} Formatted size string
 */
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
}

// Export functions for global access
window.GitLFSService = {
  initLFS,
  shouldUseLFS,
  addFileWithLFS,
  formatBytes,
  LFS_SIZE_THRESHOLD
};

console.log('[LFS] Git LFS Service loaded (threshold:', formatBytes(LFS_SIZE_THRESHOLD), ')');
