/**
 * Git LFS Service for elab2arc
 * Custom implementation - no external LFS library dependencies
 * Uses native browser crypto.subtle for SHA-256
 *
 * @module GitLFSService
 * @version 1.0.0
 */

const LFS_SIZE_THRESHOLD = 10 * 1024 * 1024; // 10MB
const LFS_CONFIG_PATH = '.gitattributes';

// LFS-specific CORS proxy that handles PUT requests for uploads
// This proxy is specifically configured to allow PUT method for GitLab LFS uploads
const LFS_UPLOAD_PROXY = 'https://lfsproxy.cplantbox.com';

/**
 * Comprehensive list of known file extensions for LFS
 * Includes archives, images, videos, audio, documents, scientific data files, and more
 */
const KNOWN_LFS_EXTENSIONS = [
  '*.zip', '*.tar.gz', '*.tar', '*.rar', '*.7z', '*.gz', '*.bz2', '*.xz',
  '*.xlsx', '*.xls', '*.docx', '*.doc', '*.pptx', '*.ppt',
  '*.odt', '*.ods', '*.odp',
  '*.psd', '*.tif', '*.tiff', '*.png', '*.jpg', '*.jpeg',
  '*.gif', '*.bmp', '*.svg', '*.webp', '*.ico', '*.heic', '*.heif',
  '*.raw', '*.cr2', '*.nef', '*.arw',
  '*.mp4', '*.avi', '*.mov', '*.mkv', '*.webm', '*.flv', '*.wmv',
  '*.mp3', '*.wav', '*.flac', '*.aac', '*.ogg', '*.wma', '*.m4a',
  '*.fasta', '*.fastq', '*.bam', '*.sam', '*.vcf', '*.npy', '*.h5', '*.hdf5',
  '*.csv', '*.tsv', '*.json', '*.xml',
  '*.vtp', '*.vtk', '*.obj', '*.ply', '*.stl', '*.fbx',
  '*.sqlite', '*.db', '*.parquet', '*.pdf'
];

/**
 * Parse existing .gitattributes and extract LFS extension patterns
 * Handles patterns with escaped spaces like *.tar[[:space:]]gz
 *
 * @param {string} content - .gitattributes file content
 * @returns {Set<string>} Set of existing extension patterns
 */
function parseExistingExtensions(content) {
  const existingPatterns = new Set();
  const lines = content.split('\n');

  for (const line of lines) {
    // Match patterns like *.ext filter=lfs or *.ext[[:space:]]ext2 filter=lfs
    // Also handle escaped spaces in the pattern
    const match = line.match(/^(\*\.\\\S+)\s+filter=lfs/);
    if (match) {
      existingPatterns.add(match[1]);
    }
  }

  return existingPatterns;
}

/**
 * Initialize LFS in repository with smart extension update
 * - Creates .gitattributes if it doesn't exist
 * - If it exists, appends missing extensions instead of replacing
 * - Preserves all existing content
 *
 * @param {object} fs - Filesystem object (memfs)
 * @param {string} gitRoot - Root directory of git repository
 * @returns {Promise<void>}
 */
async function initLFS(fs, gitRoot) {
  const gitattributesPath = `${gitRoot}/${LFS_CONFIG_PATH}`;

  let content = '';
  try {
    content = await fs.promises.readFile(gitattributesPath, 'utf8');
  } catch (e) {
    // File doesn't exist, create new
  }

  // Parse existing extensions from .gitattributes
  const existingPatterns = parseExistingExtensions(content);

  // Find missing extensions from our comprehensive list
  const missingExtensions = KNOWN_LFS_EXTENSIONS.filter(ext => !existingPatterns.has(ext));

  if (missingExtensions.length === 0) {
    console.log('[LFS] All known extensions already in .gitattributes');
    return;
  }

  // Prepare content to append
  const marker = '# Auto-generated by elab2arc LFS service';
  const hasMarker = content.includes(marker);

  const appendContent = [
    '',
    marker,
    `# ${missingExtensions.length} additional extension(s) added by elab2arc`,
    ...missingExtensions.map(ext => `${ext} filter=lfs diff=lfs merge=lfs -text`),
    ''
  ];

  // If file is empty or only has the marker, create fresh content
  if (!content.trim() || (hasMarker && existingPatterns.size === 0)) {
    const newContent = [
      marker,
      '# Large files handled by Git LFS',
      ...KNOWN_LFS_EXTENSIONS.map(ext => `${ext} filter=lfs diff=lfs merge=lfs -text`),
      ''
    ].join('\n');
    await fs.promises.writeFile(gitattributesPath, newContent);
    console.log(`[LFS] Created .gitattributes with ${KNOWN_LFS_EXTENSIONS.length} extension(s)`);
  } else {
    // Append missing extensions to existing content
    const newContent = content + appendContent.join('\n');
    await fs.promises.writeFile(gitattributesPath, newContent);
    console.log(`[LFS] Added ${missingExtensions.length} extension(s) to .gitattributes`);
  }
}

/**
 * Check if file should use LFS based on size
 *
 * @param {number} fileSize - Size of file in bytes
 * @returns {boolean} True if file should use LFS
 */
function shouldUseLFS(fileSize) {
  return fileSize > LFS_SIZE_THRESHOLD;
}

/**
 * Create LFS pointer file content
 *
 * @param {string} oid - SHA-256 OID of the file
 * @param {number} size - Size of the file in bytes
 * @returns {string} LFS pointer file content
 */
function createLFSPointer(oid, size) {
  return `version https://git-lfs.github.com/spec/v1
oid sha256:${oid}
size ${size}
`;
}

/**
 * Calculate SHA-256 of file content using browser native API
 *
 * @param {ArrayBuffer} buffer - File content buffer
 * @returns {Promise<string>} Hex-encoded SHA-256 hash
 */
async function calculateSHA256(buffer) {
  const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Upload file to LFS storage via batch API
 * Returns LFS pointer info { oid, size }
 *
 * @param {string} url - Git repository URL
 * @param {string} auth - Authorization header value
 * @param {Uint8Array} fileContent - File content to upload
 * @param {string} corsProxy - CORS proxy URL
 * @returns {Promise<{oid: string, size: number}>} LFS pointer info
 */
async function uploadToLFS(url, auth, fileContent, corsProxy) {
  const oid = await calculateSHA256(fileContent);
  const size = fileContent.byteLength;

  // Construct LFS batch API endpoint
  const repoUrl = new URL(url);
  const baseUrl = repoUrl.pathname.replace(/\.git$/, '');
  const lfsEndpoint = `${repoUrl.origin}${baseUrl}.git/info/lfs/objects/batch`;

  // LFS batch request body
  const batchRequest = {
    operation: 'upload',
    transfers: ['basic'],
    objects: [{ oid, size }]
  };

  // GitLab LFS API expects Bearer token authentication (same as regular GitLab API)
  const headers = {
    'Content-Type': 'application/vnd.git-lfs+json',
    'Accept': 'application/vnd.git-lfs+json',
    ...(auth && { 'Authorization': auth })
  };

  console.log(`[LFS] LFS endpoint: ${lfsEndpoint}`);
  console.log(`[LFS] Requesting upload for ${oid} (${(size/1024/1024).toFixed(2)}MB)`);

  let response;
  let usedProxy = false;

  // Try direct access first (many GitLab instances have proper CORS headers)
  try {
    console.log(`[LFS] Trying direct access to LFS API...`);
    response = await fetch(lfsEndpoint, {
      method: 'POST',
      headers,
      body: JSON.stringify(batchRequest)
    });
    console.log(`[LFS] Direct access response: ${response.status} ${response.statusText}`);
  } catch (directError) {
    console.log(`[LFS] Direct access failed: ${directError.message}`);
    console.log(`[LFS] Trying via CORS proxy: ${corsProxy}`);

    // Fall back to CORS proxy
    const normalizedProxy = corsProxy.endsWith('/') ? corsProxy : corsProxy + '/';
    const proxyUrl = normalizedProxy + lfsEndpoint;
    console.log(`[LFS] Proxy URL: ${proxyUrl}`);

    response = await fetch(proxyUrl, {
      method: 'POST',
      headers,
      body: JSON.stringify(batchRequest)
    });
    usedProxy = true;
    console.log(`[LFS] Proxy response: ${response.status} ${response.statusText}`);
  }

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`LFS batch API failed (${response.status}): ${errorText}`);
  }

  const result = await response.json();

  // Check for errors in response
  if (result.objects && result.objects[0] && result.objects[0].error) {
    const lfsError = result.objects[0].error;
    throw new Error(`LFS error: ${lfsError.message} (code: ${lfsError.code})`);
  }

  // Upload the actual file to the provided URL
  const uploadAction = result.objects[0].actions.upload;
  const uploadUrl = uploadAction.href;
  console.log(`[LFS] Uploading to: ${uploadUrl}`);

  // Prepare upload headers from the batch response
  // GitLab LFS provides presigned URLs with Authorization headers
  const uploadHeaders = uploadAction.header || uploadAction.headers || {};

  // Build the final upload URL
  let finalUploadUrl = uploadUrl;

  // If we used CORS proxy for batch API, we need to use LFS upload proxy for uploads
  // The presigned URL from GitLab doesn't have CORS headers for direct browser access
  // Use LFS-specific proxy that supports PUT requests
  if (usedProxy) {
    const normalizedProxy = LFS_UPLOAD_PROXY.endsWith('/') ? LFS_UPLOAD_PROXY.slice(0, -1) : LFS_UPLOAD_PROXY;
    finalUploadUrl = `${normalizedProxy}/${uploadUrl}`;
    console.log(`[LFS] Using LFS upload proxy: ${finalUploadUrl}`);
  }

  const uploadResponse = await fetch(finalUploadUrl, {
    method: 'PUT',
    headers: uploadHeaders,
    body: fileContent
  });

  if (!uploadResponse.ok) {
    const errorText = await uploadResponse.text();
    throw new Error(`LFS upload failed (${uploadResponse.status}): ${errorText}`);
  }

  console.log(`[LFS] Upload complete for ${oid} (status: ${uploadResponse.status})`);
  return { oid, size };
}

/**
 * Extract file extension from filepath
 * Handles multi-part extensions like .tar.gz by getting the last part
 *
 * @param {string} filepath - File path
 * @returns {string} Extension without dot (e.g., "zip" from "file.zip")
 */
function extractExtension(filepath) {
  const parts = filepath.split('.');
  return parts.length > 1 ? parts.pop().toLowerCase() : '';
}

/**
 * Process file for git add with LFS support
 * If file is large, checks if extension is configured for LFS
 * Shows popup for new extensions, then uploads to LFS and creates pointer file
 *
 * @param {object} fs - Filesystem object (memfs)
 * @param {object} git - isomorphic-git instance
 * @param {string} gitRoot - Root directory of git repository
 * @param {string} filepath - Relative path to file
 * @param {string} url - Git repository URL
 * @param {string} auth - Authorization header value
 * @param {string} corsProxy - CORS proxy URL
 * @returns {Promise<{usedLFS: boolean, size: number}>}
 */
async function addFileWithLFS(fs, git, gitRoot, filepath, url, auth, corsProxy) {
  const fullPath = `${gitRoot}/${filepath}`;

  try {
    // Read file content
    const content = await fs.promises.readFile(fullPath);
    const fileSize = content.byteLength;

    if (shouldUseLFS(fileSize)) {
      console.log(`[LFS] File ${filepath} (${formatBytes(fileSize)}) exceeds threshold`);

      // Extract file extension
      const extension = extractExtension(filepath);
      const fileName = filepath.split('/').pop();

      // Check if extension is configured, remembered, or skipped
      let useLFS = true;
      let isLFSConfigured = false;

      // Check .gitattributes
      const gitattributesPath = `${gitRoot}/${LFS_CONFIG_PATH}`;
      try {
        const gitattrs = await fs.promises.readFile(gitattributesPath, 'utf8');
        isLFSConfigured = isExtensionConfigured(gitattrs, extension);
      } catch (e) {
        // .gitattributes doesn't exist yet
      }

      // Check session storage
      const remembered = JSON.parse(sessionStorage.getItem('lfsRememberedExtensions') || '{}');
      const skipped = JSON.parse(sessionStorage.getItem('lfsSkippedExtensions') || '{}');

      // Show popup if not configured, not remembered, and not skipped
      if (!isLFSConfigured && !remembered[extension] && !skipped[extension]) {
        console.log(`[LFS] Extension .${extension} not configured for LFS, asking user...`);
        useLFS = await askUserForLFSExtension(extension, fileSize, fileName);

        if (useLFS) {
          // Add extension to .gitattributes
          await addLFSExtension(fs, gitRoot, extension);
          // Stage the updated .gitattributes
          await git.add({ fs, dir: gitRoot, filepath: '.gitattributes' });
          console.log(`[LFS] Staged .gitattributes with new .${extension} pattern`);
        } else {
          console.log(`[LFS] User declined LFS for .${extension}, adding normally`);
        }
      } else if (!isLFSConfigured && remembered[extension]) {
        // User said "remember" for this extension, add it automatically
        await addLFSExtension(fs, gitRoot, extension);
        await git.add({ fs, dir: gitRoot, filepath: '.gitattributes' });
        console.log(`[LFS] Auto-added .${extension} to .gitattributes (remembered)`);
      } else if (skipped[extension]) {
        // User previously skipped this extension
        useLFS = false;
        console.log(`[LFS] User previously skipped .${extension}, adding normally`);
      }

      // Proceed based on user decision
      if (useLFS) {
        console.log(`[LFS] Using LFS for ${filepath}`);

        // Upload to LFS
        const lfsInfo = await uploadToLFS(url, auth, content, corsProxy);

        // Replace with pointer file
        const pointerContent = createLFSPointer(lfsInfo.oid, lfsInfo.size);
        const pointerBuffer = new TextEncoder().encode(pointerContent);
        await fs.promises.writeFile(fullPath, pointerBuffer);

        console.log(`[LFS] Created pointer for ${filepath} (sha256:${lfsInfo.oid})`);

        // Add to git (pointer file)
        await git.add({ fs, dir: gitRoot, filepath });

        return { usedLFS: true, size: fileSize };
      } else {
        // User chose not to use LFS, add normally
        console.log(`[LFS] Adding ${filepath} normally (user declined LFS)`);
        await git.add({ fs, dir: gitRoot, filepath });
        return { usedLFS: false, size: fileSize };
      }
    }

    // File is small, add normally
    await git.add({ fs, dir: gitRoot, filepath });

    return { usedLFS: false, size: fileSize };

  } catch (error) {
    console.error(`[LFS] Error processing file ${filepath}:`, error);
    throw error;
  }
}

/**
 * Format bytes to human readable size
 *
 * @param {number} bytes - Size in bytes
 * @returns {string} Formatted size string
 */
function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
}

/**
 * Check if an extension is already configured in .gitattributes
 *
 * @param {string} content - .gitattributes file content
 * @param {string} extension - Extension to check (without asterisk/dot)
 * @returns {boolean} True if extension is already configured
 */
function isExtensionConfigured(content, extension) {
  // Check for exact pattern match or multi-part patterns
  const patterns = [
    `*.${extension} `,
    `*.${extension}\t`,
    `*.${extension}\n`
  ];
  return patterns.some(p => content.includes(p));
}

/**
 * Add extension pattern to .gitattributes
 * Appends the pattern to the end of the file
 *
 * @param {object} fs - Filesystem object (memfs)
 * @param {string} gitRoot - Root directory of git repository
 * @param {string} extension - Extension to add (without asterisk/dot)
 * @returns {Promise<void>}
 */
async function addLFSExtension(fs, gitRoot, extension) {
  const gitattributesPath = `${gitRoot}/${LFS_CONFIG_PATH}`;

  let content = '';
  try {
    content = await fs.promises.readFile(gitattributesPath, 'utf8');
  } catch (e) {
    // File doesn't exist, create new with marker
    content = '# Auto-generated by elab2arc LFS service\n';
  }

  // Check if already configured
  if (isExtensionConfigured(content, extension)) {
    console.log(`[LFS] Extension .${extension} already in .gitattributes`);
    return;
  }

  // Append new extension pattern
  const newLine = `*.${extension} filter=lfs diff=lfs merge=lfs -text`;
  const newContent = content.trimEnd() + '\n' + newLine + '\n';

  await fs.promises.writeFile(gitattributesPath, newContent);
  console.log(`[LFS] Added .${extension} to .gitattributes`);
}

/**
 * Show popup dialog asking user if large file extension should be added to LFS
 *
 * @param {string} extension - File extension (without dot)
 * @param {number} fileSize - Size of file in bytes
 * @param {string} fileName - Name of the file
 * @returns {Promise<boolean>} True if user wants to add extension to LFS
 */
async function askUserForLFSExtension(extension, fileSize, fileName) {
  const sizeMB = (fileSize / 1024 / 1024).toFixed(2);

  return new Promise((resolve) => {
    const modalId = 'lfs-extension-modal-' + Date.now();
    const modalHTML = `
      <div id="${modalId}" class="modal fade" tabindex="-1" data-bs-backdrop="static" data-bs-keyboard="false">
        <div class="modal-dialog modal-dialog-centered">
          <div class="modal-content">
            <div class="modal-header bg-warning bg-opacity-75">
              <h5 class="modal-title">
                <i class="bi bi-exclamation-triangle-fill me-2"></i>
                Large File Detected
              </h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
              <p><strong>${fileName}</strong> (${sizeMB} MB) is larger than 10MB.</p>
              <p>The extension <code class="bg-light px-1 py-1 rounded">.${extension}</code> is not currently configured for Git LFS.</p>
              <p class="mb-2">Git LFS stores large files outside the git repository to improve performance and save space.</p>
              <div class="alert alert-info mb-3">
                <small><strong>Recommendation:</strong> Add this extension to LFS for better performance with large files.</small>
              </div>
              <p class="mb-2"><strong>Do you want to add <code>*.${extension}</code> to Git LFS?</strong></p>
              <div class="form-check mt-3">
                <input class="form-check-input" type="checkbox" id="${modalId}-remember">
                <label class="form-check-label" for="${modalId}-remember">
                  Remember for this session (auto-add all .${extension} files)
                </label>
              </div>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">No, skip LFS</button>
              <button type="button" class="btn btn-primary" id="${modalId}-yes">
                <i class="bi bi-check-circle me-1"></i>Yes, add to LFS
              </button>
            </div>
          </div>
        </div>
      </div>
    `;

    // Insert modal into DOM
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    const modalElement = document.getElementById(modalId);
    const modal = new bootstrap.Modal(modalElement);

    // Get button and checkbox references
    const yesButton = document.getElementById(`${modalId}-yes`);
    const rememberCheckbox = document.getElementById(`${modalId}-remember`);

    // Handle "Yes" button click
    yesButton.addEventListener('click', () => {
      const remember = rememberCheckbox.checked;
      if (remember) {
        let remembered = JSON.parse(sessionStorage.getItem('lfsRememberedExtensions') || '{}');
        remembered[extension] = true;
        sessionStorage.setItem('lfsRememberedExtensions', JSON.stringify(remembered));
        console.log(`[LFS] Will remember .${extension} extension for this session`);
      }
      modal.hide();
    });

    // Handle modal hide event
    modalElement.addEventListener('hidden.bs.modal', () => {
      // Check if user clicked "Yes" by checking if extension is in remembered
      const remembered = JSON.parse(sessionStorage.getItem('lfsRememberedExtensions') || '{}');
      const userSaidYes = remembered[extension] === true;

      // Clean up DOM
      modalElement.remove();

      // Resolve with user's decision
      resolve(userSaidYes);
    });

    // Handle "No" button (data-bs-dismiss) by ensuring resolve(false)
    const noButton = modalElement.querySelector('[data-bs-dismiss="modal"]');
    noButton.addEventListener('click', () => {
      // Mark that user said no for this extension (to prevent repeated popups)
      let skipped = JSON.parse(sessionStorage.getItem('lfsSkippedExtensions') || '{}');
      skipped[extension] = true;
      sessionStorage.setItem('lfsSkippedExtensions', JSON.stringify(skipped));
    });

    // Show the modal
    modal.show();
  });
}

// Export functions for global access
window.GitLFSService = {
  initLFS,
  shouldUseLFS,
  addFileWithLFS,
  addLFSExtension,
  askUserForLFSExtension,
  extractExtension,
  isExtensionConfigured,
  formatBytes,
  LFS_SIZE_THRESHOLD
};

console.log('[LFS] Git LFS Service loaded (threshold:', formatBytes(LFS_SIZE_THRESHOLD), ')');
